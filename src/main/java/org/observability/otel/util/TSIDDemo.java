package org.observability.otel.util;

import io.hypersistence.tsid.TSID;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Comprehensive demo of various ID generation strategies with performance benchmarks This demo
 * compares TSIDs with UUIDs and shows key benefits
 *
 * <p>Dependencies: - io.hypersistence:hypersistence-tsid:2.0.0
 *
 * <p>Add to pom.xml: <dependency> <groupId>io.hypersistence</groupId>
 * <artifactId>hypersistence-tsid</artifactId> <version>2.0.0</version> </dependency>
 */
public class TSIDDemo {

  private static final int ITERATIONS = 1_000_000;
  private static final DateTimeFormatter FORMATTER =
      DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

  public static void main(String[] args) {
    System.out.println("=== TSID vs UUID Comparison Demo ===\n");

    // Basic TSID examples
    basicTSIDExamples();

    // UUID examples
    basicUUIDExamples();

    // TSID creation performance benchmark
    benchmarkCreation();

    // Database simulation
    simulateDatabaseIndexing();

    // Sort order demonstration
    demonstrateSortOrder();

    // String representation comparison
    compareStringRepresentation();
  }

  /** Demonstrates basic TSID operations and features */
  private static void basicTSIDExamples() {
    System.out.println("\n=== Basic TSID Examples ===");

    // Create a TSID using the default factory
    TSID tsid1 = TSID.fast();
    System.out.println("TSID (default): " + tsid1);

    // Demonstrate time extraction
    Instant creationTime = tsid1.getInstant();
    LocalDateTime dateTime = LocalDateTime.ofInstant(creationTime, ZoneId.systemDefault());
    System.out.println("Creation time: " + FORMATTER.format(dateTime));

    // Create a TSID with a custom node identifier
    TSID.Factory factory = TSID.Factory.builder().withNode(42).build();
    TSID tsid2 = factory.generate();
    System.out.println("TSID (with node 42): " + tsid2);

    // Parse a TSID from string - use a valid TSID generated by the current version
    // Note: We'll just use the string representation of the TSID we already created
    String tsidString = tsid1.toString();
    System.out.println("TSID string to parse: " + tsidString);
    TSID parsedTsid = TSID.from(tsidString);
    System.out.println("Parsed TSID: " + parsedTsid);

    // Get different representations
    System.out.println("String: " + tsid1);
    System.out.println("Long value: " + tsid1.toLong());
    System.out.println("Timestamp component: " + tsid1.getInstant().toEpochMilli());
    System.out.println("Creation time as Instant: " + tsid1.getInstant());

    // Create TSIDs from different nodes (simulating distributed system)
    System.out.println("\nSequential TSIDs from different nodes (simulating distributed system):");
    List<TSID> nodeSpecificIds = new ArrayList<>();

    // Create factories for different nodes
    for (int node = 1; node <= 5; node++) {
      TSID.Factory nodeFactory =
          TSID.Factory.builder()
              .withNode(node) // Each node gets a unique ID (1-1023)
              .build();

      nodeSpecificIds.add(nodeFactory.generate());
    }

    for (int i = 0; i < nodeSpecificIds.size(); i++) {
      System.out.printf(
          "Node %d: %s (time: %s)%n",
          i + 1, nodeSpecificIds.get(i), nodeSpecificIds.get(i).getInstant());
    }

    // Demonstrate sequential TSIDs from same node
    System.out.println("\nSequential TSIDs from same node (time-ordered):");
    TSID.Factory singleNodeFactory = TSID.Factory.builder().withNode(1).build();

    List<TSID> timeOrderedIds = new ArrayList<>();
    for (int i = 0; i < 5; i++) {
      timeOrderedIds.add(singleNodeFactory.generate());

      // Small delay to ensure time difference
      try {
        Thread.sleep(10);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }

    for (int i = 0; i < timeOrderedIds.size(); i++) {
      TSID id = timeOrderedIds.get(i);
      System.out.printf(
          "%d. %s (time: %s)%n",
          i + 1,
          id,
          FORMATTER.format(LocalDateTime.ofInstant(id.getInstant(), ZoneId.systemDefault())));
    }
  }

  /** Demonstrates UUID operations for comparison */
  private static void basicUUIDExamples() {
    System.out.println("\n=== UUID Examples ===");

    // UUID v4 (random)
    UUID uuidV4 = UUID.randomUUID();
    System.out.println("UUID v4 (random): " + uuidV4);
    System.out.println("UUID bytes: 16 bytes (128 bits)");
    System.out.println("UUID string length: " + uuidV4.toString().length() + " characters");

    // Display UUID v4 internal structure
    System.out.println("UUID v4 internal structure:");
    displayUuidStructure(uuidV4);

    // UUID v1 (time-based)
    try {
      // Using uuid-creator library for UUID v1
      // Requires: com.github.f4b6a3:uuid-creator:5.3.2
      com.github.f4b6a3.uuid.UuidCreator.getTimeBased();

      UUID uuidV1 = com.github.f4b6a3.uuid.UuidCreator.getTimeBased();
      System.out.println("\nUUID v1 (time-based): " + uuidV1);

      // Extract and display the timestamp from UUID v1
      // Conversion based on UUID v1 spec
      long timestamp = uuidV1.timestamp();
      // UUID v1 uses a custom epoch of 1582-10-15
      Instant instant =
          Instant.ofEpochMilli(
              timestamp / 10000 + (((1970 - 1582) * 365) + 89) * 24 * 60 * 60 * 1000);
      System.out.println("UUID v1 timestamp: " + instant);

      // Display UUID v1 internal structure
      System.out.println("UUID v1 internal structure:");
      displayUuidStructure(uuidV1);
    } catch (NoClassDefFoundError e) {
      System.out.println("\nUUID v1 generation requires the uuid-creator library");
      System.out.println("Add this dependency to try UUID v1:");
      System.out.println("<dependency>");
      System.out.println("    <groupId>com.github.f4b6a3</groupId>");
      System.out.println("    <artifactId>uuid-creator</artifactId>");
      System.out.println("    <version>5.3.2</version>");
      System.out.println("</dependency>");
    }

    // UUID v6 (ordered time-based)
    try {
      UUID uuidV6 = com.github.f4b6a3.uuid.UuidCreator.getTimeOrdered();
      System.out.println("\nUUID v6 (ordered time-based): " + uuidV6);
      System.out.println("UUID v6 allows for sortable time-based UUIDs");

      // Display UUID v6 internal structure
      System.out.println("UUID v6 internal structure:");
      displayUuidStructure(uuidV6);
    } catch (NoClassDefFoundError e) {
      System.out.println("\nUUID v6 generation requires the uuid-creator library");
    }

    // UUID v7 (Unix epoch time-based)
    try {
      UUID uuidV7 = com.github.f4b6a3.uuid.UuidCreator.getTimeOrderedEpoch();
      System.out.println("\nUUID v7 (Unix epoch time-based): " + uuidV7);
      System.out.println("UUID v7 uses Unix timestamp (milliseconds since 1970-01-01)");

      // Extract time component from UUID v7
      long msb = uuidV7.getMostSignificantBits();
      long timestamp = msb >>> 16; // Extract top 48 bits
      Instant instant = Instant.ofEpochMilli(timestamp);
      System.out.println("UUID v7 timestamp: " + instant);

      // Display UUID v7 internal structure
      System.out.println("UUID v7 internal structure:");
      displayUuidStructure(uuidV7);
    } catch (NoClassDefFoundError e) {
      System.out.println("\nUUID v7 generation requires the uuid-creator library");

      // Fallback to a simulated UUID v7
      System.out.println("\nSimulated UUID v7 (time-based using manual bit manipulation):");
      UUID simulatedV7 = createSimulatedUuidV7();
      System.out.println(simulatedV7);
      System.out.println(
          "Note: This is a simplified simulation, not a true UUID v7 implementation");

      // Display simulated UUID v7 internal structure
      System.out.println("Simulated UUID v7 internal structure:");
      displayUuidStructure(simulatedV7);
    }

    // Compare with TSID structure
    System.out.println("\nComparing with TSID structure:");
    TSID tsid = TSID.fast();
    System.out.println("TSID: " + tsid);
    System.out.println("TSID as long: " + tsid.toLong() + " (8 bytes / 64 bits)");
    System.out.println("TSID timestamp: " + tsid.getInstant());
    System.out.println("TSID bit layout:");
    System.out.println("- 48 bits: Unix timestamp (milliseconds)");
    System.out.println("- 16 bits: Random or node ID");
    System.out.println("- No version or variant bits needed (unlike UUIDs)");
    System.out.println("- Total: 64 bits (8 bytes) vs 128 bits (16 bytes) for UUIDs");
  }

  /** Displays the internal structure of a UUID, including version and variant bits */
  private static void displayUuidStructure(UUID uuid) {
    long msb = uuid.getMostSignificantBits();
    long lsb = uuid.getLeastSignificantBits();

    // Extract version (4 bits)
    int version = (int) ((msb >> 12) & 0xF);

    // Extract variant (2-3 bits)
    int variant = (int) ((lsb >>> 62) & 0x3);

    System.out.println(
        "Most significant bits (MSB): " + String.format("0x%016X", msb) + " (" + msb + ")");
    System.out.println(
        "Least significant bits (LSB): " + String.format("0x%016X", lsb) + " (" + lsb + ")");
    System.out.println(
        "Version bits: 0x" + Integer.toHexString(version) + " (version " + version + ")");
    System.out.println(
        "Variant bits: 0x"
            + Integer.toHexString(variant)
            + (variant == 2 ? " (RFC 4122 variant)" : " (non-standard variant)"));

    // For different UUID versions, display different components
    switch (version) {
      case 1:
        // UUID v1 specific components
        System.out.println("Time-based components:");
        System.out.println("- Timestamp (100ns since 1582-10-15): " + uuid.timestamp());
        System.out.println("- Clock sequence: " + ((lsb >> 48) & 0x3FFF));
        System.out.println("- Node ID: " + (lsb & 0xFFFFFFFFFFFL));
        break;
      case 4:
        // UUID v4 specific components - all random
        System.out.println("Contains 122 bits of randomness (excluding version and variant bits)");
        break;
      case 6:
        // UUID v6 specific components (reordered v1)
        System.out.println("Time-ordered components:");
        // Extract timestamp from UUID v6 - bit manipulation needed
        long timeHigh = (msb >>> 16) & 0xFFFFFFFFFFL;
        long timeMid = (msb & 0xFFFF) << 4;
        long timeLow = (lsb >>> 60) & 0xF;
        long timestamp = (timeHigh << 12) | timeMid | timeLow;
        System.out.println("- Reordered timestamp (100ns since 1582-10-15): " + timestamp);
        System.out.println("- Clock sequence: " + ((lsb >> 48) & 0x3FFF));
        System.out.println("- Node ID: " + (lsb & 0xFFFFFFFFFFFL));
        break;
      case 7:
        // UUID v7 specific components
        System.out.println("Time-ordered epoch components:");
        System.out.println("- Unix timestamp (ms): " + (msb >>> 16));
        System.out.println("- Sequence/random component: " + (msb & 0xFFFF));
        System.out.println(
            "- Additional random data: " + String.format("0x%016X", lsb & 0x3FFFFFFFFFFFFFFFL));
        break;
      default:
        System.out.println("Unknown UUID version");
    }
  }

  /**
   * Creates a UUID that simulates UUID v7 format This is a simplified version and not fully
   * compliant with the UUID v7 specification
   */
  private static UUID createSimulatedUuidV7() {
    long time = System.currentTimeMillis();
    byte[] randomBytes = new byte[10];
    ThreadLocalRandom.current().nextBytes(randomBytes);

    // Format:
    // - 48 bits of millisecond Unix timestamp
    // - 16 bits of "version" and sequence counter and variant
    // - 64 bits of random

    // Most significant bits: timestamp (48 bits) + version and counter (16 bits)
    long msb =
        (time << 16)
            | // Shift timestamp left, leaving 16 bits
            (0x7000
                | // Version 7
                (randomBytes[0] & 0xFFF)); // 12 bits random sequence

    // Least significant bits: random data with variant bits set
    long lsb =
        ((randomBytes[1] & 0xFFL) << 56)
            | ((randomBytes[2] & 0xFFL) << 48)
            | ((randomBytes[3] & 0xFFL) << 40)
            | ((randomBytes[4] & 0xFFL) << 32)
            | ((randomBytes[5] & 0xFFL) << 24)
            | ((randomBytes[6] & 0xFFL) << 16)
            | ((randomBytes[7] & 0xFFL) << 8)
            | (randomBytes[8] & 0xFFL);

    // Set the variant bits (2 most significant bits of the 8th byte)
    lsb = (lsb & ~(0xC000000000000000L)) | 0x8000000000000000L;

    return new UUID(msb, lsb);
  }

  /** Benchmarks the creation performance of different ID types */
  private static void benchmarkCreation() {
    System.out.println("\n=== ID Creation Performance Benchmark ===");

    // Warm up
    for (int i = 0; i < 10000; i++) {
      TSID.fast();
      UUID.randomUUID();
    }

    // TSID benchmark
    long startTime = System.nanoTime();
    for (int i = 0; i < ITERATIONS; i++) {
      TSID.fast();
    }
    long tsidTime = System.nanoTime() - startTime;

    // UUID benchmark
    startTime = System.nanoTime();
    for (int i = 0; i < ITERATIONS; i++) {
      UUID.randomUUID();
    }
    long uuidTime = System.nanoTime() - startTime;

    System.out.printf("TSID creation: %,d ns (%,d ns per op)%n", tsidTime, tsidTime / ITERATIONS);
    System.out.printf("UUID creation: %,d ns (%,d ns per op)%n", uuidTime, uuidTime / ITERATIONS);
    System.out.printf(
        "TSID is %.2fx faster than UUID for generation%n", (double) uuidTime / tsidTime);
  }

  /** Simulates database indexing behavior with different ID types */
  private static void simulateDatabaseIndexing() {
    System.out.println("\n=== Database Index Simulation ===");

    int recordCount = 100_000;

    // Simulate UUID inserts (random access pattern)
    long startTime = System.nanoTime();
    Map<UUID, Integer> uuidMap = new HashMap<>(recordCount);
    for (int i = 0; i < recordCount; i++) {
      uuidMap.put(UUID.randomUUID(), i);
    }
    long uuidTime = System.nanoTime() - startTime;

    // Simulate TSID inserts (sequential access pattern)
    startTime = System.nanoTime();
    Map<Long, Integer> tsidMap = new HashMap<>(recordCount);
    for (int i = 0; i < recordCount; i++) {
      tsidMap.put(TSID.fast().toLong(), i);
    }
    long tsidTime = System.nanoTime() - startTime;

    // Results
    System.out.printf("UUID index inserts: %,d ns%n", uuidTime);
    System.out.printf("TSID index inserts: %,d ns%n", tsidTime);
    System.out.printf("TSID inserts are %.2fx faster%n", (double) uuidTime / tsidTime);

    // Memory estimation
    long uuidMemory = recordCount * 16L; // 16 bytes per UUID
    long tsidMemory = recordCount * 8L; // 8 bytes per TSID

    System.out.printf("UUID storage (estimated): %,d bytes%n", uuidMemory);
    System.out.printf("TSID storage (estimated): %,d bytes%n", tsidMemory);
    System.out.printf(
        "TSID uses %.0f%% less storage%n", (1 - (double) tsidMemory / uuidMemory) * 100);
  }

  /** Demonstrates natural sort order of different ID types */
  private static void demonstrateSortOrder() {
    System.out.println("\n=== ID Sort Order Demonstration ===");

    // Create IDs with a delay between them
    List<TSID> tsids = new ArrayList<>();
    List<UUID> uuids = new ArrayList<>();

    System.out.println("Creating IDs with time intervals...");
    for (int i = 0; i < 5; i++) {
      tsids.add(TSID.fast());
      uuids.add(UUID.randomUUID());

      try {
        Thread.sleep(500); // 500ms delay
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }

    // Show TSID natural time order
    System.out.println("\nTSID creation order:");
    for (int i = 0; i < tsids.size(); i++) {
      TSID tsid = tsids.get(i);
      System.out.printf(
          "%d. %s (time: %s)%n",
          i + 1,
          tsid,
          FORMATTER.format(LocalDateTime.ofInstant(tsid.getInstant(), ZoneId.systemDefault())));
    }

    // Show TSID lexical sort order (should match creation order)
    System.out.println("\nTSID string sort order (should match creation order):");
    tsids.stream().map(TSID::toString).sorted().forEach(id -> System.out.println("- " + id));

    // Show UUID lexical sort order (random, not time-based)
    System.out.println("\nUUID string sort order (random, not time-based):");
    uuids.stream().map(UUID::toString).sorted().forEach(id -> System.out.println("- " + id));
  }

  /** Compares string representation efficiency of different ID types */
  private static void compareStringRepresentation() {
    System.out.println("\n=== String Representation Comparison ===");

    TSID tsid = TSID.fast();
    UUID uuid = UUID.randomUUID();

    String tsidString = tsid.toString();
    String uuidString = uuid.toString();

    System.out.println("TSID as string: " + tsidString);
    System.out.println("UUID as string: " + uuidString);

    System.out.println("TSID string length: " + tsidString.length() + " characters");
    System.out.println("UUID string length: " + uuidString.length() + " characters");

    System.out.printf(
        "TSID is %.0f%% shorter in string form%n",
        (1 - (double) tsidString.length() / uuidString.length()) * 100);

    // URL safety
    System.out.println("\nURL safety:");
    System.out.println("TSID is URL-safe by default: " + tsidString);
    System.out.println("UUID needs encoding for URLs: " + uuidString.replace("-", ""));
  }
}
